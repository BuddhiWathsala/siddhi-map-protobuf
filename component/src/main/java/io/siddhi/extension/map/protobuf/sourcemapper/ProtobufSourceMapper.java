/*
 *  Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package io.siddhi.extension.map.protobuf.sourcemapper;

import com.google.protobuf.GeneratedMessageV3;
import io.siddhi.annotation.Example;
import io.siddhi.annotation.Extension;
import io.siddhi.annotation.Parameter;
import io.siddhi.annotation.util.DataType;
import io.siddhi.core.config.SiddhiAppContext;
import io.siddhi.core.event.Event;
import io.siddhi.core.exception.SiddhiAppCreationException;
import io.siddhi.core.exception.SiddhiAppRuntimeException;
import io.siddhi.core.stream.input.source.AttributeMapping;
import io.siddhi.core.stream.input.source.InputEventHandler;
import io.siddhi.core.stream.input.source.SourceMapper;
import io.siddhi.core.util.config.ConfigReader;
import io.siddhi.core.util.transport.OptionHolder;
import io.siddhi.extension.map.protobuf.utils.GrpcConstants;
import io.siddhi.query.api.definition.Attribute;
import io.siddhi.query.api.definition.StreamDefinition;
import io.siddhi.query.api.exception.SiddhiAppValidationException;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

import static io.siddhi.extension.map.protobuf.utils.ProtobufUtils.getMethodName;
import static io.siddhi.extension.map.protobuf.utils.ProtobufUtils.getRPCmethodList;
import static io.siddhi.extension.map.protobuf.utils.ProtobufUtils.getServiceName;
import static io.siddhi.extension.map.protobuf.utils.ProtobufUtils.protobufFieldsWithTypes;

/**
 * This is a sample class-level comment, explaining what the extension class does.
 */

@Extension(
        name = "protobuf",
        namespace = "sourceMapper",
        description = "" +
                "This will convert protobuf message object in to Siddhi event \n" +
                "You have to add autogenerated protobuf message classes and service classes to the project classpath " +
                "in order to work with this mapper. Once you add them to the classpath you can " +
                "convert protobuf message object in to siddhi event.\n" +
                "If you named your stream values as same as the protobuf message definition (also in same order) this" +
                " " +
                "mapper will automatically convert protobuf message into siddhi event. Otherwise you have t ouse " +
                "@attrubute to map your stream values with protobuf message object. You can even use protobuf 'Maps' " +
                "with this mapper, In order to use Maps you should use @attribute ",
        parameters = {
                @Parameter(name = "class",
                        description = "" +
                                "This specifies the class name of the protobuf message class, If sink type is grpc " +
                                "then" +
                                " it's not necessary to provide this field.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = " "),
        },
        examples = {
                @Example(
                        syntax = "source(type='grpc', receiver.url = 'grpc://localhost: 2000/package01.test." +
                                "MyService/process', \n" +
                                "@map(type='protobuf')) " +
                                "define stream FooStream (stringValue string, intValue int,longValue long," +
                                "booleanValue bool," +
                                "floatValue float,doubleValue double); ",
                        description = "" +
                                "Above definition will convert the protobuf messages that are received to this" +
                                " source into siddhi events." +
                                ""
                ),
                @Example(
                        syntax = "source(type='grpc', receiver.url = 'grpc://localhost: 2000/package01.test." +
                                "MyService/process', \n" +
                                "@map(type='protobuf', " +
                                "@attributes(a = 'stringValue', b = 'intValue', c = 'longValue',d = 'booleanValue'," +
                                "' e = floatValue', f ='doubleValue'))) \n" +
                                "define stream FooStream (a string ,c long,b int, d bool,e float,f double);",
                        description = "" +
                                "Above definition will convert the protobuf messages that are received to this" +
                                " source into siddhi events. since there's a mapping available for the stream, " +
                                "protobuf message object will be map like this \n" +
                                "'stringValue' of the protobuf message will be assign to the 'a' attribute of the " +
                                "stream \n" +
                                "'intValue' of the protobuf message will be assign to the 'b' attribute of the stream" +
                                " \n" +
                                "'longValue' of the protobuf message will be assign to the 'c' attribute of the " +
                                "stream \n" +
                                "'booleanValue' of the protobuf message will be assign to the 'd' attribute of the " +
                                "stream \n" +
                                "'floatValue' of the protobuf message will be assign to the 'e' attribute of the " +
                                "stream \n" +
                                "'doubleValue' of the protobuf message will be assign to the 'f' attribute of the " +
                                "stream \n" +
                                ""
                ),
                @Example(
                        syntax = "source(type='grpc', receiver.url = 'grpc://localhost: 2000/package01.test." +
                                "MyService/process', \n" +
                                "@map(type='protobuf', " +
                                "@attributes(a = 'stringValue', b = 'intValue', c = 'longValue',d = 'booleanValue'," +
                                "' e = floatValue', f ='doubleValue'))) \n" +
                                "define stream FooStream (a string ,c long,b int, d bool,e float,f double);",
                        description = "" +
                                "Above definition will convert the protobuf messages that are received to this" +
                                " source into siddhi events. since there's a mapping available for the stream, " +
                                "protobuf message object will be map like this \n" +
                                "'stringValue' of the protobuf message will be assign to the 'a' attribute of the " +
                                "stream \n" +
                                "'intValue' of the protobuf message will be assign to the 'b' attribute of the stream" +
                                " \n" +
                                "'longValue' of the protobuf message will be assign to the 'c' attribute of the " +
                                "stream \n" +
                                "'booleanValue' of the protobuf message will be assign to the 'd' attribute of the " +
                                "stream \n" +
                                "'floatValue' of the protobuf message will be assign to the 'e' attribute of the " +
                                "stream \n" +
                                "'doubleValue' of the protobuf message will be assign to the 'f' attribute of the " +
                                "stream \n" +
                                ""
                ),
                @Example(
                        syntax = "source(type='grpc', receiver.url = 'grpc://localhost: 2000/package01.test." +
                                "MyService/process', \n" +
                                "@map(type='protobuf')) \n" +
                                "define stream FooStream (stringValue string ,intValue int,map object);",
                        description = "" +
                                "Above definition will convert the protobuf messages that are received to this" +
                                " source into siddhi events. since there's an object type attribute available in the" +
                                " stream (map object), mapper will assume that object is an instance of " +
                                "'java.util.Map' class. otherwise mapper will throws an exception" +
                                ""
                )
        }
)

public class ProtobufSourceMapper extends SourceMapper {

    private Class messageObjectClass;
    private List<MappingPositionData> mappingPositionDataList;
    private int size;
    private String siddhiAppName;

    /**
     * The initialization method for {@link SourceMapper}, which will be called before other methods and validate
     * the all configuration and getting the initial values.
     *
     * @param streamDefinition     Associated output stream definition
     * @param optionHolder         Option holder containing static configuration related to the {@link SourceMapper}
     * @param attributeMappingList Custom attribute mapping for source-mapping
     * @param configReader         to read the {@link SourceMapper} related system configuration.
     * @param siddhiAppContext     the context of the {@link io.siddhi.query.api.SiddhiApp} used to get siddhi
     */
    @Override
    public void init(StreamDefinition streamDefinition, OptionHolder optionHolder,
                     List<AttributeMapping> attributeMappingList, ConfigReader configReader,
                     SiddhiAppContext siddhiAppContext) {

        mappingPositionDataList = new ArrayList<>();
        this.size = streamDefinition.getAttributeList().size();
        this.siddhiAppName = siddhiAppContext.getName();
        if (sourceType.equals(GrpcConstants.GRPC_SERVICE_SOURCE_NAME) && attributeMappingList.size() == 0) {
            throw new SiddhiAppCreationException(siddhiAppName + "no mapping found at @map, mapping " +
                    "should be available to continue"); //grpc-service-source should have a mapping
        }
        String url = sourceOptionHolder.validateAndGetStaticValue(GrpcConstants.RECEIVER_URL);
        if (url == null) {
            throw new SiddhiAppValidationException(siddhiAppName + " Please provide 'receiver.url' in " +
                    "the source definition ");
        }
        URL aURL;
        try {
            aURL = new URL(GrpcConstants.DUMMY_PROTOCOL_NAME + url.substring(4));
        } catch (MalformedURLException e) {
            throw new SiddhiAppValidationException(siddhiAppName + " : MalformedURLException. "
                    + e.getMessage()); //todo update with grpc code
        }
        String methodReference = getMethodName(aURL.getPath());
        String serviceReference = getServiceName(aURL.getPath());
        String userProvidedClassName = "";
        if (optionHolder.isOptionExists(GrpcConstants.CLASS_OPTION_HOLDER)) {
            userProvidedClassName = optionHolder.validateAndGetOption(GrpcConstants.CLASS_OPTION_HOLDER).getValue();
        }
        Object messageBuilderObject; // need builder to get all the fields in the message object
        try {
            String capitalizedFirstLetterMethodName = methodReference.substring(0, 1).toUpperCase() +
                    methodReference.substring(1);
            Field methodDescriptor = Class.forName(serviceReference + GrpcConstants.GRPC_PROTOCOL_NAME_UPPERCAMELCASE)
                    .getDeclaredField(GrpcConstants.GETTER + capitalizedFirstLetterMethodName +
                            GrpcConstants.METHOD_NAME);
            ParameterizedType parameterizedType = (ParameterizedType) methodDescriptor.getGenericType();
            if (sourceType.equalsIgnoreCase(GrpcConstants.GRPC_CALL_RESPONSE_SOURCE_NAME)) {
                this.messageObjectClass = (Class) parameterizedType
                        .getActualTypeArguments()[GrpcConstants.RESPONSE_CLASS_POSITION];
            } else {
                this.messageObjectClass = (Class) parameterizedType
                        .getActualTypeArguments()[GrpcConstants.REQUEST_CLASS_POSITION];
            }
            if (!userProvidedClassName.equals("")) {
                if (url.startsWith(GrpcConstants.GRPC_PROTOCOL_NAME)) { // only if sink is a grpc type, check for
                    // both user provided class name and the required class name
                    if (!this.messageObjectClass.getName().equals(userProvidedClassName)) {
                        throw new SiddhiAppCreationException(siddhiAppName +
                                " :provided class name does not match with the original mapping class, provided class" +
                                " : "
                                + userProvidedClassName + " , expected : " + messageObjectClass.getName());
                    }
                }
            }
            Method builderMethod = messageObjectClass.getDeclaredMethod(GrpcConstants.NEW_BUILDER_NAME);
            messageBuilderObject = builderMethod.invoke(messageObjectClass);
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            throw new SiddhiAppCreationException(siddhiAppName + ": Invalid method name provided " +
                    "in the url," +
                    " provided method name : '" + methodReference + "' expected one of these methods : " +
                    getRPCmethodList(serviceReference, siddhiAppName), e);  // this error will be
        } catch (ClassNotFoundException e) {
            throw new SiddhiAppCreationException(siddhiAppName + ": " +
                    "Invalid service name provided in url, provided service name : '" + serviceReference + "'", e);
            //todo
        } catch (NoSuchFieldException e) {
            //same error as NoSuchMethod', because field is getting from the method name
            throw new SiddhiAppCreationException(siddhiAppName + ": Invalid method name provided " +
                    "in the " +
                    "url," +
                    " provided method name : '" + methodReference + "' expected one of these methods : " +
                    getRPCmethodList(serviceReference, siddhiAppName));
        }
        Field[] fields = messageBuilderObject.getClass().getDeclaredFields();
        String protobufFieldsWithTypes = protobufFieldsWithTypes(fields);
        if (attributeMappingList.size() == 0) { //if no mapping is available
            for (int i = 0; i < streamDefinition.getAttributeList().size(); i++) {
                Attribute attribute = streamDefinition.getAttributeList().get(i);
                String attributeName = attribute.getName();
                attributeName = attributeName.substring(0, 1).toUpperCase() + attributeName.substring(1);
                Attribute.Type attributeType = attribute.getType();
                Method getter;
                try {
                    if (attributeType == Attribute.Type.OBJECT) {
                        getter = messageObjectClass.getDeclaredMethod(
                                GrpcConstants.GETTER + attributeName + GrpcConstants.MAP_NAME);
                    } else {
                        getter = messageObjectClass.getDeclaredMethod(GrpcConstants.GETTER + attributeName);
                    }
                    mappingPositionDataList.add(new MappingPositionData(i, getter));
                } catch (NoSuchMethodException e) {
                    attributeName = attributeName.substring(0, 1).toLowerCase() + attributeName.substring(1);
                    throw new SiddhiAppRuntimeException(this.siddhiAppName + "Attribute name or type do " +
                            "not match with protobuf variable or type. provided attribute \"'" + attributeName + "' :" +
                            " " + attributeType + "\". Expected one of these attributes " + protobufFieldsWithTypes +
                            " ", e);
                }
            }
        } else {
            for (int i = 0; i < attributeMappingList.size(); i++) {
                AttributeMapping attributeMapping = attributeMappingList.get(i);
                String attributeName = attributeMapping.getMapping();
                int position = attributeMapping.getPosition();
                Attribute.Type attributeType = streamDefinition.getAttributeList().get(i).getType(); // to throw errors

                attributeName = attributeName.substring(0, 1).toUpperCase() + attributeName.substring(1);
                Method getter;
                try {
                    if (attributeType == Attribute.Type.OBJECT) {
                        getter = messageObjectClass.getDeclaredMethod(
                                GrpcConstants.GETTER + attributeName + GrpcConstants.MAP_NAME);
                    } else {
                        getter = messageObjectClass.getDeclaredMethod(GrpcConstants.GETTER + attributeName);
                    }
                    mappingPositionDataList.add(new MappingPositionData(position, getter));
                } catch (NoSuchMethodException e) {
                    throw new SiddhiAppRuntimeException(this.siddhiAppName + "Attribute name or type do " +
                            "not match with protobuf variable or type. provided attribute \"'" + attributeName + "' :" +
                            " " + attributeType + "\". Expected one of these attributes " + protobufFieldsWithTypes +
                            " " + e);
                }
            }
        }
    }

    /**
     * Returns the list of classes which this source can output.
     *
     * @return Array of classes that will be output by the source.
     * Null or empty array if it can produce any type of class.
     */
    @Override
    public Class[] getSupportedInputEventClasses() {
        return new Class[]{GeneratedMessageV3.class};
    }

    /**
     * Method to map the incoming event and as pass that via inputEventHandler to process further.
     *
     * @param eventObject       Incoming event Object based on the supported event class imported by the extensions.
     * @param inputEventHandler Handler to pass the converted Siddhi Event for processing
     * @throws InterruptedException if it does not throw the exception immediately due to streaming
     */
    @Override
    protected void mapAndProcess(Object eventObject, InputEventHandler inputEventHandler) throws InterruptedException {
        Object[] objectArray = new Object[this.size];
        for (MappingPositionData mappingPositionData : mappingPositionDataList) {
            Object value;
            try {
                value = mappingPositionData.getGetterMethod().invoke(eventObject);
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new SiddhiAppRuntimeException(siddhiAppName + "Unknown error occurred during " +
                        "runtime", e);
            }
            objectArray[mappingPositionData.getPosition()] = value;
        }
        Event event = new Event();
        event.setData(objectArray);
        inputEventHandler.sendEvent(event);
    }

    /**
     * Method used by {@link SourceMapper} to determine on how to handle transport properties with null values. If
     * this returns 'false' then {@link SourceMapper} will drop any event/s with null transport
     * property values. If this returns
     * 'true' then {@link SourceMapper} will send events even though they contains null transport properties.
     * This method will be called after init().
     *
     * @return whether {@link SourceMapper} should allow or drop events when transport properties are null.
     */
    @Override
    protected boolean allowNullInTransportProperties() {
        return false;
    }


    private static class MappingPositionData {
        private int position;
        private Method getterMethod;

        private MappingPositionData(int position, Method getterMethod) {
            this.position = position;
            this.getterMethod = getterMethod;
        }

        private int getPosition() {
            return position;
        }

        private Method getGetterMethod() {
            return getterMethod;
        }
    }

}

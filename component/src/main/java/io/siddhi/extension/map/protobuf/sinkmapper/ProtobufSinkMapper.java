/*
 *  Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package io.siddhi.extension.map.protobuf.sinkmapper;

import com.google.protobuf.GeneratedMessageV3;
import io.siddhi.annotation.Example;
import io.siddhi.annotation.Extension;
import io.siddhi.annotation.Parameter;
import io.siddhi.annotation.util.DataType;
import io.siddhi.core.config.SiddhiAppContext;
import io.siddhi.core.event.Event;
import io.siddhi.core.exception.SiddhiAppCreationException;
import io.siddhi.core.exception.SiddhiAppRuntimeException;
import io.siddhi.core.stream.output.sink.SinkListener;
import io.siddhi.core.stream.output.sink.SinkMapper;
import io.siddhi.core.util.config.ConfigReader;
import io.siddhi.core.util.transport.OptionHolder;
import io.siddhi.core.util.transport.TemplateBuilder;
import io.siddhi.extension.map.protobuf.utils.GrpcConstants;
import io.siddhi.extension.map.protobuf.utils.ProtobufUtils;
import io.siddhi.query.api.definition.Attribute;
import io.siddhi.query.api.definition.StreamDefinition;
import io.siddhi.query.api.exception.SiddhiAppValidationException;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static io.siddhi.extension.map.protobuf.utils.ProtobufUtils.getMethodName;
import static io.siddhi.extension.map.protobuf.utils.ProtobufUtils.getRPCmethodList;
import static io.siddhi.extension.map.protobuf.utils.ProtobufUtils.getServiceName;
import static io.siddhi.extension.map.protobuf.utils.ProtobufUtils.protobufFieldsWithTypes;


/**
 * Mapper class to convert a Siddhi message to a Protobuf(Protocol Buffers)  message object
 */
@Extension(
        name = "protobuf",
        namespace = "sinkMapper",

        description = "" +
                "This extension is an Event to Protobuf Message Object." +
                "You have to add autogenerated protobuf message classes and service classes to the project classpath " +
                "in order to work with this mapper. Once you add them to the classpath you can convert Siddhi Event " +
                "objects to protobuf message object.\n" +
                "If you named your stream values as same as the protobuf message definition " +
                "(also in the same order) this mapper will " +
                "automatically convert Siddhi Event to protobuf message type, Otherwise you have to use @payload to " +
                "map your stream values with protobuf message object(Example 2). You can even use protobuf Maps " +
                "with this mapper, In order to use maps you should use  HashMap " +
                ", LinkedHashMap or TreeMap and pass them directly to the stream as an object (Example 3).Please find" +
                " the sample proto definition [here](https://github.com/siddhi-io/siddhi-io/siddhi-map-protobuf/" +
                "tree/master/component/src/main/resources/) " +
                "   ",
        parameters = {
                @Parameter(name = "class",
                        description = "" +
                                "This specifies the class name of the protobuf message class, If sink type is grpc " +
                                "then" +
                                " it's not necessary to provide this parameter.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = " "),
        },
        examples = {
                @Example(
                        syntax = "@sink(type='grpc',  url = 'grpc://localhost:2000/org.wso2.grpc.test" +
                                ".MyService/process \n" +
                                "@map(type='protobuf')) \n" +
                                "define stream BarStream (stringValue string, intValue int,longValue long," +
                                "booleanValue bool," +
                                "floatValue float,doubleValue double)",
                        description = "Above definition will map BarStream values into the protobuf message type of " +
                                "the " +
                                " 'process' method in 'MyService' service" +
                                ""),

                @Example(
                        syntax = "@sink(type='grpc', url = 'grpc://localhost:2000/org.wso2.grpc.test" +
                                ".MyService/process\n" +
                                "@map(type='protobuf'), \n" +
                                "@payload(stringValue='a',longValue='b',intValue='c',booleanValue='d',floatValue = " +
                                "'e', doubleValue  = 'f'))) \n" +
                                "define stream BarStream (a string, b long, c int,d bool,e float,f double);",

                        description = "The above definition will map BarStream values to request message type of the " +
                                "'process' method in 'MyService' service. and stream values will map like this, \n" +
                                "- value of 'a' will be assign 'stringValue' variable in the message class \n" +
                                "- value of 'b' will be assign 'longValue' variable in the message class \n" +
                                "- value of 'c' will be assign 'intValue' variable in the message class \n" +
                                "- value of 'd' will be assign 'booleanValue' variable in the message class \n" +
                                "- value of 'e' will be assign 'floatValue' variable in the message class \n" +
                                "- value of 'f' will be assign 'doubleValue' variable in the message class \n" +
                                ""
                ),
                @Example(
                        syntax = "@sink(type='grpc', url = 'grpc://localhost:2000/org.wso2.grpc.test" +
                                ".MyService/testMap' \n" +
                                "@map(type='protobuf')) \n" +
                                " define stream BarStream (stringValue string,intValue int,map object);",

                        description = "The above definition will map BarStream values to request message type of the " +
                                "'testMap' method in 'MyService' service and since there is an object data type is in" +
                                " " +
                                "the stream(map object) , mapper will assume that 'map' is an instance of  " +
                                "'java.util.Map' class, otherwise it will throws and error. \n" +
                                ""
                )
        }
)

public class ProtobufSinkMapper extends SinkMapper {

    private Class builder;
    private Class messageObjectClass;
    private Object messageBuilderObject;
    private List<MappingPositionData> mappingPositionDataList;
    private String siddhiAppName;


    /**
     * Returns a list of supported dynamic options (that means for each event value of the option can change) by
     * the transport
     *
     * @return the list of supported dynamic option keys
     */
    @Override
    public String[] getSupportedDynamicOptions() {
        return new String[0];
    }

    /**
     * The initialization method for {@link SinkMapper}, which will be called before other methods and validate
     * the all configuration and getting the initial values.
     *
     * @param streamDefinition containing stream definition bind to the {@link SinkMapper}
     * @param optionHolder     Option holder containing static and dynamic configuration related
     *                         to the {@link SinkMapper}
     * @param map              Unmapped payload for reference
     * @param configReader     to read the sink related system configuration.
     * @param siddhiAppContext the context of the {@link io.siddhi.query.api.SiddhiApp} used to
     *                         get siddhi related utilty functions.
     */
    @Override
    public void init(StreamDefinition streamDefinition, OptionHolder optionHolder, Map<String, TemplateBuilder> map,
                     ConfigReader configReader, SiddhiAppContext siddhiAppContext) {
        String[] attributeNameArray = streamDefinition.getAttributeNameArray();
        this.siddhiAppName = siddhiAppContext.getName();
        if (sinkType.equals(GrpcConstants.GRPC_SERVICE_RESPONSE_SINK_NAME) && map.size() == 0) {
            throw new SiddhiAppCreationException(siddhiAppContext.getName() + "no mapping found at @map, mapping " +
                    "should be available to continue"); //grpc-service-source should have a mapping
        }
        String url = sinkOptionHolder.validateAndGetStaticValue(GrpcConstants.PUBLISHER_URL);
        URL aURL;
        try {
            aURL = new URL(GrpcConstants.DUMMY_PROTOCOL_NAME + url.substring(4));
        } catch (MalformedURLException e) {
            throw new SiddhiAppValidationException(siddhiAppContext.getName() + ": MalformedURLException. "
                    + e.getMessage());
        }
        String methodReference = getMethodName(aURL.getPath());
        String serviceReference = getServiceName(aURL.getPath());
        //if user provides the class parameter inside the @map
        String userProvidedClassName = "";
        if (optionHolder.isOptionExists(GrpcConstants.CLASS_OPTION_HOLDER)) {
            userProvidedClassName = optionHolder.validateAndGetOption(GrpcConstants.CLASS_OPTION_HOLDER).getValue();
        }
        try {
            String capitalizedFirstLetterMethodName = methodReference.substring(0, 1).toUpperCase() +
                    methodReference.substring(1);
            Field methodDescriptor = Class.forName(serviceReference + GrpcConstants.GRPC_PROTOCOL_NAME_UPPERCAMELCASE)
                    .getDeclaredField(GrpcConstants.GETTER + capitalizedFirstLetterMethodName +
                            GrpcConstants.METHOD_NAME);
            ParameterizedType parameterizedType = (ParameterizedType) methodDescriptor.getGenericType();
            if (sinkType.equalsIgnoreCase(GrpcConstants.GRPC_SERVICE_RESPONSE_SINK_NAME)) {
                this.messageObjectClass = (Class) parameterizedType.
                        getActualTypeArguments()[GrpcConstants.RESPONSE_CLASS_POSITION];
            } else {
                this.messageObjectClass = (Class) parameterizedType.
                        getActualTypeArguments()[GrpcConstants.REQUEST_CLASS_POSITION];
            }
            if (!userProvidedClassName.equals("")) {
                if (url.startsWith(GrpcConstants.GRPC_PROTOCOL_NAME)) { // only if sink is a grpc type, check for
                    // both user provided class name and the required class name
                    if (!this.messageObjectClass.getName().equals(userProvidedClassName)) {
                        throw new SiddhiAppCreationException(siddhiAppContext.getName() +
                                " :provided class name does not match with the original mapping class, provided class" +
                                " : "
                                + userProvidedClassName + " , expected : " + messageObjectClass.getName());
                    }
                }
            }
            // create and instantiate the object
            Method builderMethod = messageObjectClass.getDeclaredMethod(GrpcConstants.NEW_BUILDER_NAME); //to
            // create an builder object of message class
            this.builder = builderMethod.getReturnType();
            messageBuilderObject = builderMethod.invoke(this.messageObjectClass);

        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            throw new SiddhiAppCreationException(siddhiAppContext.getName() + ": Invalid method name provided " +
                    "in the url," +
                    " provided method name : '" + methodReference + "' expected one of these methods : " +
                    getRPCmethodList(serviceReference, siddhiAppName), e);  // this error will be
            // thrown if invalid method name is provided.
        } catch (ClassNotFoundException e) {
            throw new SiddhiAppCreationException(siddhiAppContext.getName() + ": " +
                    "Invalid service name provided in url, provided service name : '" + serviceReference + "'", e);
        } catch (NoSuchFieldException e) {
            throw new SiddhiAppCreationException(siddhiAppContext.getName() + ": Invalid method name provided " +
                    "in the " +
                    "url," +
                    " provided method name : '" + methodReference + "' expected one of these methods : " +
                    getRPCmethodList(serviceReference, siddhiAppName), e);
        }

        Field[] fields = messageBuilderObject.getClass().getDeclaredFields();
        String protobufFieldsWithTypes = protobufFieldsWithTypes(fields);
        mappingPositionDataList = new ArrayList<>();
        if (map == null) {
            for (int i = 0; i < streamDefinition.getAttributeList().size(); i++) {
                Attribute.Type attributeType = streamDefinition.getAttributeList().get(i).getType(); //get attribute
                // type
                String attributeName = attributeNameArray[i]; //get attribute name
                attributeName = attributeName.substring(0, 1).toUpperCase() + attributeName.substring(1);
                Method setterMethod;
                try {
                    if (attributeType == Attribute.Type.OBJECT) {
                        setterMethod = builder.getDeclaredMethod(GrpcConstants.PUTALL_METHOD + attributeName,
                                java.util.Map.class);
                    } else {
                        setterMethod = builder.getDeclaredMethod(GrpcConstants.SETTER + attributeName,
                                ProtobufUtils.getDataType(attributeType));
                    }
                    mappingPositionDataList.add(new MappingPositionData(setterMethod, i));
                } catch (NoSuchMethodException e) {
                    throw new SiddhiAppRuntimeException(this.siddhiAppName + "Attribute name or type do " +
                            "not match with protobuf variable or type. provided attribute \"'" + attributeName + "' :" +
                            " " + attributeType + "\". Expected one of these attributes " + protobufFieldsWithTypes +
                            " " + e);
                }

            }
        } else {
            List<String> mapKeySetList = new ArrayList<>(map.keySet()); //convert keyset to a list, to get keys by index
            for (int i = 0; i < map.size(); i++) {
                String attributeName = mapKeySetList.get(i); //get attribute name
                Attribute.Type attributeType = map.get(attributeName).getType();
                attributeName = attributeName.substring(0, 1).toUpperCase() + attributeName.substring(1);
                Method setterMethod;
                try {
                    if (attributeType == Attribute.Type.OBJECT) {
                        setterMethod = builder.getDeclaredMethod(GrpcConstants.PUTALL_METHOD + attributeName,
                                java.util.Map.class);
                    } else {
                        setterMethod = builder.getDeclaredMethod(GrpcConstants.SETTER + attributeName,
                                ProtobufUtils.getDataType(attributeType));
                    }
                    mappingPositionDataList.add(new MappingPositionData(setterMethod, map.get(mapKeySetList.get(i))));
                } catch (NoSuchMethodException e) {
                    String attributeTypeName = attributeType.name(); //to change object to map
                    if (attributeType == Attribute.Type.OBJECT) {
                        attributeTypeName = "Map";
                    }
                    throw new SiddhiAppRuntimeException(this.siddhiAppName + "Attribute name or type do " +
                            "not match with protobuf variable or type. provided attribute \"'" + attributeName + "' :" +
                            " " + attributeTypeName + "\". Expected on of these attributes " + protobufFieldsWithTypes +
                            " ", e);
                }
            }
        }

    }


    /**
     * Returns the list of classes which this sink can consume.
     * Based on the type of the sink, it may be limited to being able to publish specific type of classes.
     * For example, a {@link SinkMapper} of type event can convert to CSV file objects of type String or byte.
     *
     * @return array of supported classes , if extension can support of any types of classes then return empty array .
     */
    @Override
    public Class[] getOutputEventClasses() {
        return new Class[]{GeneratedMessageV3.class};
    }

    /**
     * Method to map the events and send them to {@link SinkListener} for publishing
     *
     * @param events       {@link Event}s that need to be mapped
     * @param optionHolder Option holder containing static and dynamic options related to the mapper
     * @param map          To build the message payload based on the given template
     * @param sinkListener {@link SinkListener} that will be called with the mapped events
     */
    @Override
    public void mapAndSend(Event[] events, OptionHolder optionHolder, Map<String, TemplateBuilder> map,
                           SinkListener sinkListener) {
        for (Event event : events) {
            mapAndSend(event, optionHolder, map, sinkListener);
        }
    }

    /**
     * Method to map the event and send it to {@link SinkListener} for publishing
     *
     * @param event        {@link Event} that need to be mapped
     * @param optionHolder Option holder containing static and dynamic options related to the mapper
     * @param map          To build the message payload based on the given template
     * @param sinkListener {@link SinkListener} that will be called with the mapped event
     */
    @Override
    public void mapAndSend(Event event, OptionHolder optionHolder, Map<String, TemplateBuilder> map,
                           SinkListener sinkListener) {
        //todo error and just save the name
        if (map != null) { // if @payload available data will be getting from the Template builder
            for (int i = 0; i < mappingPositionDataList.size(); i++) {
                MappingPositionData mappingPositionData = this.mappingPositionDataList.get(i);
                Object data = mappingPositionData.getTemplateBuilder().build(event); // need to throw exception
                try {
                    mappingPositionData.getMessageObjectSetterMethod().invoke(messageBuilderObject, data);
                } catch (IllegalArgumentException | IllegalAccessException | InvocationTargetException e) {
                    String nameOfExpectedClass =
                            mappingPositionData.getMessageObjectSetterMethod().getParameterTypes()[0].getName();
                    String nameOfFoundClass = data.getClass().getName();
                    String[] foundClassnameArray = nameOfFoundClass.split("\\.");
                    nameOfFoundClass = foundClassnameArray[foundClassnameArray.length - 1]; // to get the last name
                    throw new SiddhiAppRuntimeException(this.siddhiAppName + " : Data type do not match. " +
                            "Expected data type : '" + nameOfExpectedClass + "' found : '" + nameOfFoundClass + "'", e);
                }
            }
        } else {
            for (int i = 0; i < mappingPositionDataList.size(); i++) {
                MappingPositionData mappingPositionData = mappingPositionDataList.get(i);
                Object data = event.getData(mappingPositionData.getPosition());
                try {
                    mappingPositionData.getMessageObjectSetterMethod().invoke(messageBuilderObject, data);
                } catch (IllegalArgumentException | IllegalAccessException | InvocationTargetException e) {
                    String nameOfExpectedClass =
                            mappingPositionData.getMessageObjectSetterMethod().getParameterTypes()[0].getName();
                    String nameOfFoundClass = data.getClass().getName();
                    String[] foundClassnameArray = nameOfFoundClass.split("\\.");
                    nameOfFoundClass = foundClassnameArray[foundClassnameArray.length - 1]; // to get the last name
                    throw new SiddhiAppRuntimeException(this.siddhiAppName + " : Data type do not match. " +
                            "Expected data type : '" + nameOfExpectedClass + "' found : '" + nameOfFoundClass + "'", e);
                }
            }
        }
        try {
            Method buildMethod = builder.getDeclaredMethod(GrpcConstants.BUILD_METHOD, null);
            Object messageObject = buildMethod.invoke(messageBuilderObject); //get the message object by invoking
            // build() method
            sinkListener.publish(messageObject);
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            throw new SiddhiAppRuntimeException(this.siddhiAppName + " : Error while creating the message " +
                    "object", e);
        }
    }


    private static class MappingPositionData {
        private Method messageObjectSetterMethod;
        private TemplateBuilder templateBuilder;
        private int position; //this attribute can be removed

        private MappingPositionData(Method messageObjectSetterMethod, int position) {
            this.messageObjectSetterMethod = messageObjectSetterMethod;
            this.position = position; //if mapping is not available
        }

        private MappingPositionData(Method messageObjectSetterMethod, TemplateBuilder templateBuilder) {
            this.messageObjectSetterMethod = messageObjectSetterMethod;
            this.templateBuilder = templateBuilder;
        }

        private Method getMessageObjectSetterMethod() {
            return messageObjectSetterMethod;
        }

        private TemplateBuilder getTemplateBuilder() {
            return templateBuilder;
        }

        private int getPosition() {
            return position;
        }
    }
}
